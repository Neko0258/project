\documentclass[12pt,a4paper]{report}
\usepackage[left=3.00cm, right=2.00cm, top=2.00cm, bottom=2.00cm]{geometry}
\usepackage{vntex}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{tabularx}
\usepackage{colortbl}
\usepackage{hhline}
\newcommand{\shellcmd}[1]{\\\indent\indent\texttt{\footnotesize\# #1}\\}
\newcommand{\nocontentsline}[3]{}
\newcommand{\tocless}[2]{\bgroup\let\addcontentsline=\nocontentsline#1{#2}\egroup}
\author{DSH + NAT}
\usepackage{tikz}
\usetikzlibrary{calc}
\title{Đề cương chi tiết Ver 1}

\begin{document}
	\begin{titlepage}
		\begin{tikzpicture}[remember picture,overlay,inner sep=0,outer sep=0]
			\draw[blue!70!black,line width=4pt] ([xshift=-1.5cm,yshift=-2cm]current page.north east) coordinate (A)--([xshift=1.5cm,yshift=-2cm]current page.north west) coordinate(B)--([xshift=1.5cm,yshift=2cm]current page.south west) coordinate (C)--([xshift=-1.5cm,yshift=2cm]current page.south east) coordinate(D)--cycle;
			
			\draw ([yshift=0.5cm,xshift=-0.5cm]A)-- ([yshift=0.5cm,xshift=0.5cm]B)--
			([yshift=-0.5cm,xshift=0.5cm]B) --([yshift=-0.5cm,xshift=-0.5cm]B)--([yshift=0.5cm,xshift=-0.5cm]C)--([yshift=0.5cm,xshift=0.5cm]C)--([yshift=-0.5cm,xshift=0.5cm]C)-- ([yshift=-0.5cm,xshift=-0.5cm]D)--([yshift=0.5cm,xshift=-0.5cm]D)--([yshift=0.5cm,xshift=0.5cm]D)--([yshift=-0.5cm,xshift=0.5cm]A)--([yshift=-0.5cm,xshift=-0.5cm]A)--([yshift=0.5cm,xshift=-0.5cm]A);
			
			
			\draw ([yshift=-0.3cm,xshift=0.3cm]A)-- ([yshift=-0.3cm,xshift=-0.3cm]B)--
			([yshift=0.3cm,xshift=-0.3cm]B) --([yshift=0.3cm,xshift=0.3cm]B)--([yshift=-0.3cm,xshift=0.3cm]C)--([yshift=-0.3cm,xshift=-0.3cm]C)--([yshift=0.3cm,xshift=-0.3cm]C)-- ([yshift=0.3cm,xshift=0.3cm]D)--([yshift=-0.3cm,xshift=0.3cm]D)--([yshift=-0.3cm,xshift=-0.3cm]D)--([yshift=0.3cm,xshift=-0.3cm]A)--([yshift=0.3cm,xshift=0.3cm]A)--([yshift=-0.3cm,xshift=0.3cm]A);
			
		\end{tikzpicture}
		\begin{center}
			BAN CƠ YẾU CHÍNH PHỦ\\
			\textbf{HỌC VIỆN KỸ THUẬT MẬT MÃ}
		\end{center}
		\begin{figure}[h]
			\centering
			\includegraphics[width=0.25\linewidth]{"Pics/Logo HV"}
			\label{fig:logo-hv}
		\end{figure}
		
		\begin{center}
			{\Huge ĐỀ CƯƠNG\\}
			{\large CHUYÊN ĐỀ AN TOÀN HỆ THỐNG THÔNG TIN\\}
			\textbf{Nghiên cứu giải pháp đảm bảo an toàn dữ liệu trên Kubernetes}
		\end{center}
		\bigskip
		\begin{flushright}
			\large{Ngành: An toàn thông tin}
		\end{flushright}
		\vspace{30mm}
		\begin{flushleft}
			\textit{Sinh viên thực hiện:}\\
			\textbf{Nguyễn Anh Tuấn}\\
			Mã sinh viên: AT160258\\
			\textbf{Đặng Sơn Hà}\\
			Mã sinh viên: AT160220
			\bigskip\\
			\textit{Người hướng dẫn:}\\
			\textbf{TS. Nguyễn Mạnh Thắng}\\
			Khoa An toàn thông tin - Học viện Kỹ thuật mật mã
		\end{flushleft}
		\vfill
		\begin{center}
			Hà Nội, 2022
		\end{center}
		
	\end{titlepage}
	
	\tableofcontents
	
	\chapter*{\centering Lời cảm ơn}
	\addcontentsline{toc}{chapter}{Lời cảm ơn}
	\hspace{1cm}Nhóm chúng em xin chân thành cảm ơn các thầy cô trường Học viện Kỹ thuật Mật mã nói chung, quý thầy cô của khoa An toàn thông tin nói riêng đã tận tình dạy bảo, truyền đạt kiến thức cho chúng em trong suốt quá trình học.\\
	
	\hspace{1cm} Kính gửi đến Thầy Nguyễn Mạnh Thắng lời cảm ơn chân thành và sâu sắc nhất, cảm ơn thầy đã tận tình theo sát, chỉ bảo và hướng dẫn cho nhóm em trong quá trình thực hiện đề tài này. Thầy không chỉ hướng dẫn chúng em những kiến thức chuyên ngành, mà còn giúp chúng em học thêm những kĩ năng mềm, tinh thần học hỏi, thái độ khi làm việc nhóm.\\
	
	\hspace{1cm}Trong quá trình tìm hiểu nhóm chúng em xin cảm ơn các bạn sinh viên đã góp ý, giúp đỡ và hỗ trợ nhóm em rất nhiều trong quá trình tìm hiểu và làm đề tài.\\
	
	\hspace{1cm}Do kiến thức còn nhiều hạn chế nên không thể tránh khỏi những thiếu sót trong quá trình làm đề tài.Chúng em rất mong nhận được sự đóng góp ý kiến của quý thầy cô để đề tài của chúng em đạt được kết quả tốt hơn.\\
	\bigskip \\
	\textbf{Chúng em xin chân thành cảm ơn!}
	\chapter*{\centering Lời mở đầu}
	\addcontentsline{toc}{chapter}{Lời mở đầu}
	\hspace{1cm}{Trong những năm gần đây, Kubernetes đã trở thành một trong những công cụ quản lý container phổ biến nhất. Điều này là do sự phát triển mạnh mẽ của Kubernetes, cũng như sự phổ biến của container. Trong các doanh nghiệp hiện nay, Kubernetes là một phần không thể thiếu được sử dụng để quản lý các ứng dụng container, cung cấp các dịch vụ như load balancing, autoscaling, logging, monitoring, backup và restore, cũng như quản lý các tài nguyên của các ứng dụng như CPU, Memory, Storage, Network. Tuy nhiên, việc sử dụng Kubernetes cũng có những hạn chế, đặc biệt là trong việc quản lý các cấu hình nhạy cảm của ứng dụng và các tài nguyên của ứng dụng. Vì vậy, trong đề tài này, chúng ta sẽ tìm hiểu về Vault, một công cụ quản lý secret phổ biến nhất hiện nay, được phát triển bởi HashiCorp. \\}
	
	{\hspace{0.3cm}Vault được sử dụng để quản lý các secret như username, password, token, key, certificate, API key, SSH key, license key, database connection và các thông tin khác. Vì vậy trong tương lai, Vault sẽ là một trong những công cụ quản lý secret không thể thiếu trong Kubernetes.\\}
	
	\hspace{0.3cm}Với những lí do trên, bài toán đặt ra ở đây là làm sao để triển khai Vault trên cụm Kubernetes. Vậy nên, đề tài “Nghiên cứu giải pháp đảm bảo an toàn dữ liệu trên K8S” được thực hiện trong báo cáo có ý nghĩa khoa học và mang tính thực tiễn cao.\\
	
	\chapter{Giới thiệu về Kurbenetes}
	\section{Tổng quan về Kurbenetes}
	\smallskip
	\hspace{1cm}{Kubernetes hoặc k8s là một nền tảng mã nguồn mở giúp tự động hóa việc quản lý, mở rộng và triển khai ứng dụng dưới dạng container. Kubernetes còn được gọi là Container Orchestration Engine (hiểu nôm na là công cụ điều phối container). Kubernetes loại bỏ rất nhiều các quy trình thủ công liên quan đến việc triển khai và mở rộng các containerized applications. Các ứng dụng có thể khác nhau về kích thước: từ 1 cho đến hàng nghìn server. Với Kubernetes chúng ta có thể phát triển application một cách linh hoạt và đáng tin cậy. \\}
	
	\hspace{0.3cm}{Trách nhiệm chính của Kubernetes là container orchestration (dịch ra có nghĩa điều phối container). Kubernetes đảm bảo rằng tất cả container được lên lịch chạy trên các cụm server (cluster) (server ở đây có thể là physical machine hoặc virtual machine). Ngoài ra, Kubernetes còn có chức năng theo dõi hoạt động của từng container, mở rộng các containers và quản lý tình trạng của các containers theo thời gian. Khi một container nào đó gặp trục trặc, dừng hoạt động thì Kubernetes sẽ thay thế container đó. \\}
	
	\hspace{0.3cm}{Kubernetes ban đầu được các kỹ sư Google phát triển vào năm 2014. Và Google cũng là một trong những cái tên tiên phong đóng góp cho công cuộc phát triển công nghệ Linux container. \\}
	
	\hspace{0.3cm}{Kubernetes ban đầu được các kỹ sư Google phát triển vào năm 2014. Và Google cũng là một trong những cái tên tiên phong đóng góp cho công cuộc phát triển công nghệ Linux container. \\}
	
	\hspace{0.3cm}{Red Hat là một trong những công ty đầu tiên hợp tác với Google trong dự án Kubernetes trước khi Kubernetes được ra mắt, và trở thành nhà tài trợ lớn thứ 2 cho dự án ngay từ những ngày đầu. Và Google đã tặng lại dự án Kubernetes cho Cloud Native Computing Foundation (CNCF - thành lập năm 2015). Kubernetes đã trở thành một project của tổ chức này cho đến thời điểm hiện tại. Năm 2018, Kubernetes Project đạt vị trí thứ 9 về số lượt commit trên Github.}
	\subsection{Các thành phần trong kubernetes}
	\smallskip
	\hspace{1cm}{Khi bạn triển khai Kubernetes, bạn sẽ nhận được một Cluster (cụm máy chủ). \\}
	
	\hspace{0.3cm}{Một Cluster Kubernetes bao gồm một tập hợp các máy worker, được gọi là Node, chạy các ứng dụng được đóng gói. Mỗi Cluster có ít nhất một Node. \\}
	
	\hspace{0.3cm}{(Các) Node lưu trữ các Pod - Một nhóm gồm một hoặc nhiều containers được triển khai cho single Node, nhóm này chia sẻ chung không gian lưu trữ, IP address, hostname, và những nguồn khác. \\}
	
	\hspace{0.3cm}{Các Control Plane quản lý các Node và các Pod trong Cluster. Trong môi trường production, Control Plane thường chạy trên nhiều máy tính và một Cluster thường chạy nhiều Node, mang lại khả năng chịu lỗi và tính sẵn sàng cao. \\}
	
	\hspace{0.3cm}{Trên đây là sơ đồ của một cụm Kubernetes với tất cả các thành phần được gắn với nhau.}
	
	\begin{figure}
		\centering
		\includegraphics[width=1\textwidth]{"Pics/components-of-kubernetes"}
		\caption{\label{fig:components-of-kubernetes} Sơ đồ của một cụm Kubernetes.}
		\label{fig:components-of-kubernetes}
	\end{figure}
	
	\subsubsection{Các thành phần Control Plane (Master)}
	\smallskip
	\hspace{1cm}{Các thành phần Control Plane đưa ra các quyết định chung về Cluster (ví dụ: lập lịch), cũng như phát hiện và phản hồi các sự kiện của Cluster. \\}
	
	\hspace{0.3cm}{Các thành phần Control Plane có thể được chạy trên bất kỳ máy nào trong Cluster. Tuy nhiên, để đơn giản, thiết lập tập lệnh thường khởi động tất cả các thành phần Control Plane trên cùng một máy và không chạy các container của người dùng trên máy này. \\}
	
	\hspace{0.3cm}{Đối với cluster nhỏ , Master có thể chạy trên một Node, nhưng trong một cluster lớn, để đảm bảo tính khả dụng (trong tiếng anh là High-Availability) thì Master có thể được chạy trên nhiều Node. (Tính khả dụng có nghĩa là Khi mà một Node trong cluster dừng hoạt động thì hệ thống vẫn duy trì như không có gì xảy ra). Master sẽ bao gồm 5 thành phần chính sau:}
	
	\begin{itemize}
		\item \textbf{kube-apiserver:}
		\subitem
		API Server là một thành phần của Control Plane. Đúng theo tên gọi, đây chính là server cung cấp REST API cho Kubernetes Cluster. Nó có nhiệm vụ đặt Pod vào Node, đồng bộ hoá thông tin của Pod bằng REST API tiếp nhận cài đặt, xác thực và thiết lập cho các objects pod/service/replicationController.
		
		\item \textbf{Etcd:}
		\subitem
		Etcd là Kho lưu trữ giá trị khóa nhất quán và có tính khả dụng cao được sử dụng làm kho dự phòng để lưu trữ toàn bộ cấu hình, trạng thái và metadata của Kubernetes Cluster.
		
		\hspace{0.8cm}{Trong các cluster nhỏ, Etcd có thể chạy trên cùng một Node với các thành phần khác. Nhưng trong các cluster lớn, Etcd có thể chạy dự phòng trên nhiều Node để đảm bảo tính khả dụng của toàn hệ thống. Nếu cụm Kubernetes của bạn sử dụng Etcd làm nơi lưu trữ sao lưu, hãy đảm bảo rằng bạn có kế hoạch sao lưu cho những dữ liệu đó.}
		
		\item \textbf{kube-controller-manager:}
		\subitem
		Kube Controller Manage một tập hợp các controller khác nhau để chạy các bộ điều khiển quy trình theo dõi các cập nhật trạng thái của Kubernetes Cluster thông qua API và thực hiện các thay đổi đối với Cluster sao cho phù hợp. 
		
		\hspace{0.8cm}{Về mặt logic, mỗi bộ điều khiển là một quy trình riêng biệt, nhưng để giảm độ phức tạp, tất cả chúng đều được biên dịch thành một tệp nhị phân duy nhất và chạy trong một quy trình duy nhất. }
		
		\hspace{0.8cm}{Một số loại bộ điều khiển có thể kể đến:}
		\begin{itemize}
			\item Node controller: Chịu trách nhiệm thông báo và phản hồi khi các Node gặp sự cố.
			
			\item Job controller: Kiểm soát các tác vụ được lập lịch, sau đó tạo các Pod để chạy các tác vụ đó đến khi hoàn thành.
			
			\item Endpoints controller: Điền khiển đối tượng Điểm cuối (nghĩa là tham gia Dịch vụ \& Nhóm).
			
			\item Service Account \& Token controllers: Tạo tài khoản mặc định và mã thông báo truy cập API cho không gian tên mới.
		\end{itemize}
		
		\item \textbf{cloud-controller-manager:}
		\subitem
		Là một tập hợp các logic dành riêng cho đám mây (GCP, AWS, Azure) cho phép bạn liên kết Kubernetes Cluster với API của nhà cung cấp đám mây và tách các thành phần tương tác với nền tảng đám mây đó khỏi các thành phần chỉ tương tác với cụm của bạn. Cloud-controller-manager chỉ chạy các bộ điều khiển dành riêng cho nhà cung cấp dịch vụ đám mây của bạn. Nếu bạn đang chạy Kubernetes tại cơ sở của riêng mình hoặc trong môi trường học tập bên trong PC của riêng bạn, cụm không có trình quản lý bộ điều khiển đám mây.
		
		\hspace{0.8cm}{Cũng như với kube-controller-manager, cloud-controller-manager kết hợp một số vòng điều khiển độc lập về mặt logic thành một tệp nhị phân duy nhất mà bạn chạy như một quy trình duy nhất. Bạn có thể chia tỷ lệ theo chiều ngang (chạy nhiều hơn một bản sao) để cải thiện hiệu suất hoặc để giúp tăng khả năng chịu lỗi. }
		
		\hspace{0.8cm}{Các bộ điều khiển sau có thể có các phần phụ thuộc của nhà cung cấp dịch vụ đám mây:}
		\begin{itemize}
			\item Node controller: Để kiểm tra nhà cung cấp đám mây để xác định xem một Node đã bị xóa trong đám mây sau khi nó ngừng phản hồi hay chưa.
			
			\item Route controller: Để thiết lập định tuyến trong cơ sở hạ tầng đám mây cơ bản.
			
			\item Service controller: Để tạo, cập nhật và xóa bộ cân bằng tải của nhà cung cấp dịch vụ đám mây.
		\end{itemize}
		
		\item \textbf{kube-scheduler:}
		\subitem
		Sử dụng Kubernetes API để tìm, theo dõi các Pod chưa được lên lịch hoặc mới được tạo nhưng không được chỉ định Node. Sau đó, scheduler sẽ đặt các Pod này vào các Node dựa trên tài nguyên và các ràng buộc khác được định nghĩa trong manifest file của Pod. Scheduler sẽ cố gắng đảm bảo rằng các Pod của cùng một application sẽ được phân phối trên các Node khác nhau để đảm bảo tính khả dụng.
		
		\hspace{0.8cm}{Các yếu tố được tính đến để đưa ra quyết định lập lịch bao gồm: yêu cầu tài nguyên cá nhân và tập thể, các ràng buộc về phần cứng / phần mềm / chính sách, thông số kỹ thuật về mối quan hệ và chống mối quan hệ, vị trí dữ liệu, can thiệp giữa khối lượng công việc và thời hạn.}
	\end{itemize}
	
	\subsubsection{Các thành phần Worker}
	\smallskip
	\hspace{1cm}{Có nhiệm vụ xử lý khối lượng công việc của application trong cluster, duy trì các nhóm đang chạy và cung cấp môi trường runtime cho Kubernetes. Worker sẽ bao gồm 3 thành phần chính sau:}
	\begin{itemize}
		\item \textbf{kubelet:}
		\subitem
		Kubelet chạy trên mỗi Worker Node. Nó đảm bảo rằng các container đang chạy trong một Pod và có trách nhiệm giám sát giao tiếp với master node và quản lý các Pod. Kubelet sử dụng CRI (Container Runtime Interface - Giao diện thời gian chạy vùng chứa) để giao tiếp với container runtime trên cùng một Node đó. Kubelet không quản lý các vùng chứa không được tạo bởi Kubernetes.
		
		\item \textbf{kube-proxy:}
		\subitem
		Là một proxy mạng chạy trên mỗi Node trong Cluster. Nó có trách nhiệm quản lý, duy trì các quy tắc mạng trên mỗi Node. Các quy tắc mạng này cho phép giao tiếp mạng với Pod của bạn từ các phiên mạng bên trong hoặc bên ngoài Cluster. kube-proxy sử dụng lớp lọc gói của hệ điều hành nếu có và nó có sẵn. Nếu không, kube-proxy sẽ tự chuyển tiếp lưu lượng.
		
		\item \textbf{Container Runtime:}
		\subitem
		Là phần mềm chịu trách nhiệm chạy các container. Kubernetes hỗ trợ một số container runtime như: Docker, containerd, CRI-O và bất kỳ triển khai nào của Kubernetes CRI (Container Runtime Interface).
	\end{itemize}
	
	\section{Các đối tượng trong Kubernetes}
	\smallskip
	\subsection{Giới thiệu các đối tượng trong Kubernetes}
	\smallskip
	
	\subsection{Quản lý các đối tượng trong Kubernetes}
	\smallskip
	\hspace{1cm}{Công cụ dòng lệnh \texttt{kubectl} hỗ trợ một số cách khác nhau để tạo và quản lý các đối tượng Kubernetes. Tài liệu này cung cấp một cái nhìn tổng quan về các cách tiếp cận khác nhau.}
	
	\textbf{Kỹ thuật quản lý:} 
	Một đối tượng Kubernetes chỉ nên được quản lý bằng một kỹ thuật. Các kỹ thuật trộn lẫn và kết hợp cho cùng một đối tượng dẫn đến hành vi không xác định.
	
	\begin{table}
		\centering
		\begin{tabular}{|c|c|c|l} 
			\hhline{|---~}
			{\cellcolor[rgb]{0.753,0.753,0.753}}Kỹ thuât quản lý            & {\cellcolor[rgb]{0.753,0.753,0.753}}Hoạt động trên & {\cellcolor[rgb]{0.753,0.753,0.753}}Môi trường đề xuất &   \\ 
			\hhline{|---~}
			{\cellcolor[rgb]{0.937,0.937,0.937}}Dòng lệnh bắt buộc          & Đối tượng trực tiếp                                & Dự án phát triển                                       &   \\ 
			\hhline{|---~}
			{\cellcolor[rgb]{0.937,0.937,0.937}}Cấu hình đối tượng bắt buộc & Các tệp riêng lẻ                                   & Dự án sản xuất                                         &   \\ 
			\hhline{|---~}
			{\cellcolor[rgb]{0.937,0.937,0.937}}Cấu hình đối tượng khai báo & Thư mục của tập tin                                & Dự án sản xuất                                         &   \\
			\hhline{|---~}
		\end{tabular}
	\end{table}
	
	\subsubsection{Dòng lệnh bắt buộc}
	\smallskip
	\hspace{1cm}{Khi sử dụng các dòng lệnh bắt buộc, người dùng thao tác trực tiếp trên các đối tượng trực tiếp trong một cụm. Người dùng cung cấp các hoạt động cho lệnh \texttt{kubectl} dưới dạng đối số hoặc cờ.\\}
	
	\hspace{0.3cm}{Đây là cách được đề xuất để bắt đầu hoặc chạy tác vụ một lần trong cụm. Vì kỹ thuật này hoạt động trực tiếp trên các đối tượng trực tiếp nên nó không cung cấp lịch sử của các cấu hình trước đó. \\}
	
	\hspace{0.3cm}{\textbf{Ví dụ:} Chạy một phiên bản nginx container bằng cách tạo một đối tượng Deployment: \\}
	\shellcmd{kubectl create deployment nginx --image nginx}
	
	\hspace{0.3cm}{\textbf{So sánh:}}
	\begin{itemize}
		\item Ưu điểm so với cấu hình đối tượng:
		\begin{itemize}
			\item Các lệnh được thể hiện dưới dạng một từ hành động.
			\item Các lệnh chỉ yêu cầu một bước duy nhất để thực hiện các thay đổi đối với cụm.
		\end{itemize}
		\item Nhược điểm so với cấu hình đối tượng:
		\begin{itemize}
			\item Các lệnh không tích hợp với các quy trình xem xét thay đổi.
			\item Các lệnh không cung cấp dấu vết kiểm tra liên quan đến các thay đổi.
			\item Các lệnh không cung cấp nguồn bản ghi ngoại trừ những gì đang hoạt động.
			\item Các lệnh không cung cấp mẫu để tạo đối tượng mới.
		\end{itemize}
	\end{itemize}
	
	\subsubsection{Cấu hình đối tượng bắt buộc}
	\smallskip
	\hspace{1cm}{Trong cấu hình đối tượng bắt buộc, lệnh \texttt{kubectl} chỉ định thao tác (tạo, thay thế, v.v.), các cờ tùy chọn và ít nhất một tên tệp. Tệp được chỉ định phải chứa định nghĩa đầy đủ về đối tượng ở định dạng YAML hoặc JSON.}
	
	\hspace{0.3cm}{\textbf{Ví dụ:} Tạo các đối tượng được xác định trong tệp cấu hình: \\}
	\shellcmd{kubectl create -f nginx.yaml \\}
	Xóa các đối tượng được xác định trong hai tệp cấu hình:\\
	\shellcmd{kubectl delete -f nginx.yaml -f redis.yaml\\}
	Cập nhật các đối tượng được xác định trong tệp cấu hình bằng cách ghi đè lên cấu hình trực tiếp:\\
	\shellcmd{kubectl replace -f nginx.yaml}
	
	\hspace{0.3cm}{\textbf{So sánh:}}
	\begin{itemize}
		\item Ưu điểm so với dòng lệnh bắt buộc:
		\begin{itemize}
			\item Cấu hình đối tượng có thể được lưu trữ trong một hệ thống kiểm soát nguồn như Git.
			\item Cấu hình đối tượng có thể tích hợp với các quy trình như xem xét các thay đổi trước khi đẩy và theo dõi kiểm tra.
			\item Cấu hình đối tượng cung cấp một mẫu để tạo các đối tượng mới.
		\end{itemize}
		\item Nhược điểm so với dòng lệnh bắt buộc:
		\begin{itemize}
			\item Cấu hình đối tượng yêu cầu hiểu biết cơ bản về lược đồ đối tượng.
			\item Cấu hình đối tượng yêu cầu thêm bước ghi tệp YAML.
		\end{itemize}
		\item Ưu điểm so với cấu hình đối tượng khai báo:
		\begin{itemize}
			\item Hành vi cấu hình đối tượng bắt buộc đơn giản hơn và dễ hiểu hơn.
			\item Kể từ phiên bản Kubernetes 1.5, cấu hình đối tượng bắt buộc đã hoàn thiện hơn.
		\end{itemize}
		\item Nhược điểm so với cấu hình đối tượng khai báo:
		\begin{itemize}
			\item Cấu hình đối tượng bắt buộc hoạt động tốt nhất trên tệp chứ không phải thư mục.
			\item Các bản cập nhật cho các đối tượng trực tiếp phải được phản ánh trong các tệp cấu hình, nếu không chúng sẽ bị mất trong lần thay thế tiếp theo.
		\end{itemize}
	\end{itemize}
	
	\subsubsection{Cấu hình đối tượng khai báo}
	\smallskip
	\hspace{1cm}{Khi sử dụng cấu hình đối tượng khai báo, người dùng thao tác trên tệp cấu hình đối tượng được lưu trữ cục bộ, tuy nhiên người dùng không xác định các thao tác được thực hiện trên tệp. Các hoạt động tạo, cập nhật và xóa được tự động phát hiện trên mỗi đối tượng bởi \texttt{kubectl}. Điều này cho phép làm việc trên các thư mục, nơi có thể cần các thao tác khác nhau cho các đối tượng khác nhau.\\}
	
	\hspace{0.8cm}{Lưu ý: Cấu hình đối tượng khai báo giữ lại các thay đổi do người viết khác thực hiện, ngay cả khi các thay đổi không được hợp nhất trở lại tệp cấu hình đối tượng. Điều này có thể thực hiện được bằng cách sử dụng thao tác \texttt{patch} API để chỉ ghi những điểm khác biệt được quan sát, thay vì sử dụng thao tác \texttt{replace} API để thay thế toàn bộ cấu hình đối tượng.\\}
	
	\hspace{0.3cm}{\textbf{Ví dụ:} Xử lý tất cả các tệp cấu hình đối tượng trong thư mục \texttt{configs} và tạo hoặc vá các đối tượng trực tiếp. Trước tiên, bạn có thể \texttt{diff} xem những thay đổi nào sẽ được thực hiện, sau đó áp dụng: \\}
	\shellcmd{kubectl diff -f configs/}
	\shellcmd{kubectl apply -f configs/}
	\noindent Xử lý đệ quy các thư mục:\\
	\shellcmd{kubectl diff -R -f configs/
	\shellcmd{kubectl apply -R -f configs/}
		
	\hspace{0.3cm}{\textbf{So sánh:}}
	\begin{itemize}
		\item Ưu điểm so với dòng lệnh bắt buộc:
		\begin{itemize}
			\item Cấu hình đối tượng có thể được lưu trữ trong một hệ thống kiểm soát nguồn như Git.
			\item Cấu hình đối tượng có thể tích hợp với các quy trình như xem xét các thay đổi trước khi đẩy và theo dõi kiểm tra.
			\item Cấu hình đối tượng cung cấp một mẫu để tạo các đối tượng mới.
		\end{itemize}
		\item Nhược điểm so với dòng lệnh bắt buộc:
		\begin{itemize}
			\item Cấu hình đối tượng yêu cầu hiểu biết cơ bản về lược đồ đối tượng.
			\item Cấu hình đối tượng yêu cầu thêm bước ghi tệp YAML.
		\end{itemize}
		\item Ưu điểm so với cấu hình đối tượng khai báo:
		\begin{itemize}
			\item Hành vi cấu hình đối tượng bắt buộc đơn giản hơn và dễ hiểu hơn.
			\item Kể từ phiên bản Kubernetes 1.5, cấu hình đối tượng bắt buộc đã hoàn thiện hơn.
		\end{itemize}
		\item Nhược điểm so với cấu hình đối tượng khai báo:
		\begin{itemize}
			\item Cấu hình đối tượng bắt buộc hoạt động tốt nhất trên tệp chứ không phải thư mục.
			\item Các bản cập nhật cho các đối tượng trực tiếp phải được phản ánh trong các tệp cấu hình, nếu không chúng sẽ bị mất trong lần thay thế tiếp theo.
		\end{itemize}
	\end{itemize}
\end{document}